<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content="default-src 'self'; style-src-attr 'unsafe-inline'" http-equiv=Content-Security-Policy><title>Polymorphism in C++ and Rust: type erasure | よ waifod</title><link as=font crossorigin href=https://waifod.dev/fonts/FiraCode-Regular.woff2 rel=preload type=font/woff2><link as=font crossorigin href=https://waifod.dev/fonts/FiraCode-Bold.woff2 rel=preload type=font/woff2><link href="https://waifod.dev/css/style.css?h=287f84ed6c66dca911c6" rel=stylesheet><link href=https://waifod.dev/favicon.svg rel=icon type=text/svg+xml><script src="https://waifod.dev/js/auto-close-popover-on-resize.js?h=4ef87d6fc7b98b22e044" defer></script><script src="https://waifod.dev/js/copy-code-to-clipboard.js?h=b34dc626be3e4c8a0f55" defer></script><link href=https://waifod.dev/blog/polymorphism-type-erasure/ rel=canonical><link title="よ waifod" href=https://waifod.dev/atom.xml rel=alternate type=application/atom+xml><meta content="Matteo Durante" name=author><meta content="In which I teach myself C++ type erasure, and discover why Rust's trait system makes most of it unnecessary…" name=description><meta content="index, follow" name=robots><meta content=#211f1a name=theme-color><meta content=dark name=color-scheme><meta content="Polymorphism in C++ and Rust: type erasure" property=og:title><meta content=article property=og:type><meta content=https://waifod.dev/blog/polymorphism-type-erasure/ property=og:url><meta content="In which I teach myself C++ type erasure, and discover why Rust's trait system makes most of it unnecessary…" property=og:description><meta content="よ waifod" property=og:site_name><meta content=2026-02-08T12:09:57.332146443+00:00 property=og:updated_time><meta content=2026-01-24T00:00:00+00:00 property=article:published_time><meta content=c++ property=article:tag><meta content=rust property=article:tag><meta content=programming property=article:tag><meta content=patterns property=article:tag><body class=layout-center data-theme=terminus><header class=header><div class=header-container><span class=header-logo-container> <a href=https://waifod.dev> <span class=logo>よ waifod</span> </a> </span></div><nav aria-label="Main Menu" class=main-menu><a class=skip-to-content href=#main>Skip to main content</a><button class=main-menu-dropdown-button popovertarget=nav-menu>Menu</button><ul aria-label="Site Navigation" class=main-menu-items id=nav-menu popover><li><a href=https://waifod.dev/blog/>blog</a><li><a href=https://waifod.dev/tags/>tags</a><li><a href=https://github.com/waifod target=_blank>github</a></ul></nav></header><main id=main><article class="post content"><header><h1 class=post-title><a href=https://waifod.dev/blog/polymorphism-type-erasure/>Polymorphism in C++ and Rust: type erasure</a></h1><ul class="post-meta hidden"><li title="Published on 2026-01-24"><time datetime=2026-01-24>2026.01.24</time><li aria-hidden=true role=separator>::<li title="1388 words"><time datetime=PT7M>7 min</time> read</ul><div class=post-tags><span>#<a href=https://waifod.dev/tags/c/ rel=tag>c++</a></span><span>#<a href=https://waifod.dev/tags/rust/ rel=tag>rust</a></span><span>#<a href=https://waifod.dev/tags/programming/ rel=tag>programming</a></span><span>#<a href=https://waifod.dev/tags/patterns/ rel=tag>patterns</a></span></div></header><nav class=toc><h2>Contents</h2><ul><li><a href=https://waifod.dev/blog/polymorphism-type-erasure/#the-problem>The problem</a><li><a href=https://waifod.dev/blog/polymorphism-type-erasure/#classic-dynamic-polymorphism>Classic dynamic polymorphism</a><li><a href=https://waifod.dev/blog/polymorphism-type-erasure/#template-based-polymorphism>Template-based polymorphism</a><li><a href=https://waifod.dev/blog/polymorphism-type-erasure/#external-polymorphism>External polymorphism</a><li><a href=https://waifod.dev/blog/polymorphism-type-erasure/#enter-type-erasure>Enter type erasure</a><li><a href=https://waifod.dev/blog/polymorphism-type-erasure/#implementing-type-erasure>Implementing type erasure</a> <ul><li><a href=https://waifod.dev/blog/polymorphism-type-erasure/#c-the-manual-approach>C++: the manual approach</a><li><a href=https://waifod.dev/blog/polymorphism-type-erasure/#rust-first-class-trait-objects>Rust: first-class trait objects</a><li><a href=https://waifod.dev/blog/polymorphism-type-erasure/#rust-the-c-style>Rust: the C++ style</a></ul><li><a href=https://waifod.dev/blog/polymorphism-type-erasure/#where-c-has-the-edge>Where C++ has the edge</a><li><a href=https://waifod.dev/blog/polymorphism-type-erasure/#conclusion>Conclusion</a></ul></nav><p>In which I teach myself C++ type erasure, and discover why Rust's trait system makes most of it unnecessary.</p><span id=continue-reading></span><h2 id=the-problem>The problem</h2><p>Type erasure is one of those techniques that sounds like it solves a problem you don't have until you have it.<p>Say you want to implement a <code>Shape</code> class with an <code>area()</code> method. You have circles, squares, maybe triangles later. The obvious approach is inheritance: define a base class, override the virtual method, store pointers in a container. It works, but now your API is littered with <code>unique_ptr</code> and heap allocations are visible to callers. What if you want the same polymorphic behavior but with value semantics, where the memory management is an implementation detail, not part of your interface?<p>That's the problem type erasure solves. We'll start from the familiar virtual function approach, see where it falls short, and build up to a technique that gives you polymorphism without exposing the plumbing.<h2 id=classic-dynamic-polymorphism>Classic dynamic polymorphism</h2><p>The traditional object-oriented solution uses inheritance and virtual functions. We start with an interface:<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span style=color:#b48ead>struct </span><span>Shape {
</span><span>    </span><span style=color:#b48ead>virtual </span><span style=color:#8fa1b3>~Shape</span><span>() = </span><span style=color:#b48ead>default</span><span>;
</span><span>    </span><span style=color:#b48ead>virtual double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const </span><span>= </span><span style=color:#d08770>0</span><span>;
</span><span>};
</span></code></pre><p>Then add <code>Circle</code> and <code>Square</code>:<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span style=color:#b48ead>struct </span><span>Circle : </span><span style=color:#a3be8c>Shape </span><span>{
</span><span>    </span><span style=color:#b48ead>double</span><span> radius_;
</span><span>    </span><span style=color:#8fa1b3>Circle</span><span>(</span><span style=color:#b48ead>double </span><span style=color:#bf616a>r</span><span>) : </span><span style=color:#bf616a>radius_</span><span>(r) {}
</span><span>    </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const override </span><span>{ </span><span style=color:#b48ead>return</span><span> M_PI * radius_ * radius_; }
</span><span>};
</span><span>
</span><span style=color:#b48ead>struct </span><span>Square : </span><span style=color:#a3be8c>Shape </span><span>{
</span><span>    </span><span style=color:#b48ead>double</span><span> side_;
</span><span>    </span><span style=color:#8fa1b3>Square</span><span>(</span><span style=color:#b48ead>double </span><span style=color:#bf616a>s</span><span>) : </span><span style=color:#bf616a>side_</span><span>(s) {}
</span><span>    </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const override </span><span>{ </span><span style=color:#b48ead>return</span><span> side_ * side_; }
</span><span>};
</span></code></pre><p>Now we can store different shapes in a container and use them generically:<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span style=color:#b48ead>int </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    std::vector&lt;std::unique_ptr&lt;Shape>> shapes;
</span><span>    shapes.</span><span style=color:#bf616a>emplace_back</span><span>(std::</span><span style=color:#bf616a>make_unique</span><span>&lt;Circle>(</span><span style=color:#d08770>5.0</span><span>));
</span><span>    shapes.</span><span style=color:#bf616a>emplace_back</span><span>(std::</span><span style=color:#bf616a>make_unique</span><span>&lt;Square>(</span><span style=color:#d08770>4.0</span><span>));
</span><span>    
</span><span>    </span><span style=color:#b48ead>for </span><span>(</span><span style=color:#b48ead>const auto</span><span>& shape : shapes) {
</span><span>        std::cout &lt;&lt; "</span><span style=color:#a3be8c>Area: </span><span>" &lt;&lt; shape-></span><span style=color:#bf616a>area</span><span>() &lt;&lt; "</span><span style=color:#96b5b4>\n</span><span>";
</span><span>    }
</span><span>}
</span></code></pre><p>The Rust version looks similar:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>use </span><span>std::f64::consts::</span><span style=color:#d08770>PI</span><span>;
</span><span>
</span><span style=color:#b48ead>trait </span><span>Shape {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64</span><span>;
</span><span>}
</span><span>
</span><span style=color:#b48ead>struct </span><span>Circle { </span><span style=color:#bf616a>radius</span><span>: </span><span style=color:#b48ead>f64 </span><span>}
</span><span>
</span><span style=color:#b48ead>impl </span><span>Shape </span><span style=color:#b48ead>for </span><span>Circle {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64 </span><span>{ </span><span style=color:#d08770>PI </span><span>* </span><span style=color:#bf616a>self</span><span>.radius * </span><span style=color:#bf616a>self</span><span>.radius }
</span><span>}
</span><span>
</span><span style=color:#b48ead>struct </span><span>Square { </span><span style=color:#bf616a>side</span><span>: </span><span style=color:#b48ead>f64 </span><span>}
</span><span>
</span><span style=color:#b48ead>impl </span><span>Shape </span><span style=color:#b48ead>for </span><span>Square {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64 </span><span>{ </span><span style=color:#bf616a>self</span><span>.side * </span><span style=color:#bf616a>self</span><span>.side }
</span><span>}
</span><span>
</span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    </span><span style=color:#b48ead>let</span><span> shapes: Vec&lt;Box&lt;dyn Shape>> = vec![
</span><span>        Box::new(Circle { radius: </span><span style=color:#d08770>5.0 </span><span>}),
</span><span>        Box::new(Square { side: </span><span style=color:#d08770>4.0 </span><span>}),
</span><span>    ];
</span><span>    
</span><span>    </span><span style=color:#b48ead>for</span><span> shape in &shapes {
</span><span>        println!("</span><span style=color:#a3be8c>Area: </span><span style=color:#d08770>{}</span><span>", shape.</span><span style=color:#96b5b4>area</span><span>());
</span><span>    }
</span><span>}
</span></code></pre><p>This works, but notice the <code>unique_ptr</code> and <code>Box</code> in the container types. The pointer semantics are baked into your API. There's also a second limitation in C++: types must inherit from the base class, so you can't make existing types polymorphic without modifying them.<h2 id=template-based-polymorphism>Template-based polymorphism</h2><p>If types can't share a base class, you might reach for templates instead:<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span style=color:#b48ead>void </span><span style=color:#8fa1b3>print_area</span><span>(</span><span style=color:#b48ead>const auto</span><span>& </span><span style=color:#bf616a>shape</span><span>) {
</span><span>    std::cout &lt;&lt; "</span><span style=color:#a3be8c>Area: </span><span>" &lt;&lt; shape.</span><span style=color:#bf616a>area</span><span>() &lt;&lt; "</span><span style=color:#96b5b4>\n</span><span>";
</span><span>}
</span></code></pre><p>This works for any type with an <code>area()</code> method, no inheritance required. Templates generate code for each type you use, so if you pass something without <code>area()</code>, the compiler errors when it tries to instantiate the template. But it has two problems.<p>First, there's no common type. Each template instantiation is distinct, so you can't store a mix of <code>Circle</code> and <code>Square</code> in one container:<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span>std::vector&lt;???> shapes;  </span><span style=color:#65737e>// What type goes here?
</span></code></pre><p>Second, templates are viral. Any function that calls <code>print_area</code> must either know the concrete type or be a template itself. This spreads templates across the codebase, making it harder to read and increasing compile times and binary size.<h2 id=external-polymorphism>External polymorphism</h2><p>External polymorphism addresses the intrusiveness problem. If you have types that don't share a base class, you can wrap them in a polymorphic interface and treat them uniformly. Say <code>Circle</code> and <code>Square</code> don't inherit from anything:<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span style=color:#b48ead>struct </span><span>Circle {
</span><span>    </span><span style=color:#b48ead>double</span><span> radius;
</span><span>    </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const </span><span>{ </span><span style=color:#b48ead>return</span><span> M_PI * radius * radius; }
</span><span>};
</span><span>
</span><span style=color:#b48ead>struct </span><span>Square {
</span><span>    </span><span style=color:#b48ead>double</span><span> side;
</span><span>    </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const </span><span>{ </span><span style=color:#b48ead>return</span><span> side * side; }
</span><span>};
</span></code></pre><p>We define a wrapper interface and a templated implementation that forwards to the wrapped object:<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span style=color:#b48ead>struct </span><span>ShapeWrapper {
</span><span>    </span><span style=color:#b48ead>virtual </span><span style=color:#8fa1b3>~ShapeWrapper</span><span>() = </span><span style=color:#b48ead>default</span><span>;
</span><span>    </span><span style=color:#b48ead>virtual double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const </span><span>= </span><span style=color:#d08770>0</span><span>;
</span><span>};
</span><span>
</span><span style=color:#b48ead>template</span><span>&lt;</span><span style=color:#b48ead>typename</span><span> T>
</span><span style=color:#b48ead>struct </span><span>ShapeWrapperImpl : </span><span style=color:#a3be8c>ShapeWrapper </span><span>{
</span><span>    T shape_;
</span><span>    </span><span style=color:#8fa1b3>ShapeWrapperImpl</span><span>(T </span><span style=color:#bf616a>s</span><span>) : </span><span style=color:#bf616a>shape_</span><span>(std::</span><span style=color:#bf616a>move</span><span>(s)) {}
</span><span>    </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const override </span><span>{ </span><span style=color:#b48ead>return</span><span> shape_.</span><span style=color:#bf616a>area</span><span>(); }
</span><span>};
</span></code></pre><p>Now we can store <code>Circle</code> and <code>Square</code> in the same container:<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span style=color:#b48ead>int </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    std::vector&lt;std::unique_ptr&lt;ShapeWrapper>> shapes;
</span><span>    shapes.</span><span style=color:#bf616a>emplace_back</span><span>(std::</span><span style=color:#bf616a>make_unique</span><span>&lt;ShapeWrapperImpl&lt;Circle>>(</span><span style=color:#bf616a>Circle</span><span>{</span><span style=color:#d08770>5.0</span><span>}));
</span><span>    shapes.</span><span style=color:#bf616a>emplace_back</span><span>(std::</span><span style=color:#bf616a>make_unique</span><span>&lt;ShapeWrapperImpl&lt;Square>>(</span><span style=color:#bf616a>Square</span><span>{</span><span style=color:#d08770>4.0</span><span>}));
</span><span>    
</span><span>    </span><span style=color:#b48ead>for </span><span>(</span><span style=color:#b48ead>const auto</span><span>& shape : shapes) {
</span><span>        std::cout &lt;&lt; "</span><span style=color:#a3be8c>Area: </span><span>" &lt;&lt; shape-></span><span style=color:#bf616a>area</span><span>() &lt;&lt; "</span><span style=color:#96b5b4>\n</span><span>";
</span><span>    }
</span><span>}
</span></code></pre><p>This pattern lets you add polymorphism to types you don't control, but it still exposes pointers in your API.<p>Rust doesn't need this pattern because traits are <em>non-intrusive</em> by design. You can implement traits for types without modifying them<sup class=footnote-reference id=fr-newtype-1><a href=#fn-newtype>1</a></sup>:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>use </span><span>std::f64::consts::</span><span style=color:#d08770>PI</span><span>;
</span><span>
</span><span style=color:#b48ead>struct </span><span>ThirdPartyCircle { </span><span style=color:#bf616a>radius</span><span>: </span><span style=color:#b48ead>f64 </span><span>}
</span><span>
</span><span style=color:#b48ead>trait </span><span>Shape {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64</span><span>;
</span><span>}
</span><span>
</span><span style=color:#b48ead>impl </span><span>Shape </span><span style=color:#b48ead>for </span><span>ThirdPartyCircle {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64 </span><span>{ </span><span style=color:#d08770>PI </span><span>* </span><span style=color:#bf616a>self</span><span>.radius * </span><span style=color:#bf616a>self</span><span>.radius }
</span><span>}
</span></code></pre><p>A key difference: C++ needs the external polymorphism pattern as a workaround, while Rust's trait system provides it naturally.<h2 id=enter-type-erasure>Enter type erasure</h2><p>We've solved intrusiveness, but pointers are still visible in the API. Type erasure hides them. The idea is: what if the heap allocation was an implementation detail, not something your callers had to think about?<p>Consider <code>std::function</code> in C++:<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>functional</span><span>>
</span><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>iostream</span><span>>
</span><span>
</span><span style=color:#b48ead>void </span><span style=color:#8fa1b3>print_result</span><span>(std::function&lt;</span><span style=color:#b48ead>int</span><span>(</span><span style=color:#b48ead>int</span><span>, </span><span style=color:#b48ead>int</span><span>)> </span><span style=color:#bf616a>op</span><span>) {
</span><span>    std::cout &lt;&lt; </span><span style=color:#bf616a>op</span><span>(</span><span style=color:#d08770>3</span><span>, </span><span style=color:#d08770>4</span><span>) &lt;&lt; "</span><span style=color:#96b5b4>\n</span><span>";
</span><span>}
</span><span>
</span><span style=color:#b48ead>int </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    </span><span style=color:#65737e>// Different types, same interface
</span><span>    </span><span style=color:#bf616a>print_result</span><span>([](</span><span style=color:#b48ead>int</span><span> a, </span><span style=color:#b48ead>int</span><span> b) { </span><span style=color:#b48ead>return</span><span> a + b; });     </span><span style=color:#65737e>// Lambda
</span><span>    </span><span style=color:#bf616a>print_result</span><span>(std::</span><span style=color:#bf616a>multiplies</span><span>&lt;</span><span style=color:#b48ead>int</span><span>>{});                 </span><span style=color:#65737e>// Functor
</span><span>    </span><span style=color:#bf616a>print_result</span><span>([](</span><span style=color:#b48ead>int</span><span> a, </span><span style=color:#b48ead>int</span><span> b) { </span><span style=color:#b48ead>return</span><span> a * b; });     </span><span style=color:#65737e>// Different lambda
</span><span>}
</span></code></pre><p>Notice:<ul><li>we pass by value, not by pointer;<li>each callable has a different type;<li>no inheritance required;<li>the concrete type is "erased" behind <code>std::function</code>.</ul><p>That's type erasure: the concrete type is hidden behind a uniform interface, and callers use value semantics.<section class="alert note" aria-labelledby=HyH0KRE0 role=note><div class="alert-icon alert-icon-note"></div><div class=alert-content role=presentation><strong aria-hidden=true class=alert-title id=HyH0KRE0>NOTE</strong><p>The heap allocation still happens internally, but it's an implementation detail hidden from callers.</div></section><h2 id=implementing-type-erasure>Implementing type erasure</h2><h3 id=c-the-manual-approach>C++: the manual approach</h3><p>C++ doesn't provide type erasure as a language feature. You build it yourself, which is either empowering or exhausting depending on your disposition. The standard approach uses the "external polymorphism" pattern (see Sean Parent's <a href="https://www.youtube.com/watch?v=2bLkxj6EVoM"><em>Inheritance Is The Base Class of Evil</em></a> talk and Klaus Iglberger's <a href=https://www.oreilly.com/library/view/c-software-design/9781098113155/><em>C++ Software Design</em></a> for in-depth treatments).<p>The idea is to nest the polymorphic machinery inside a value-semantic wrapper. First, define a <code>Concept</code> (the interface) and a templated <code>Model</code> (the wrapper):<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span style=color:#b48ead>struct </span><span>Shape {
</span><span>    </span><span style=color:#b48ead>struct </span><span>Concept {
</span><span>        </span><span style=color:#b48ead>virtual </span><span style=color:#8fa1b3>~Concept</span><span>() = </span><span style=color:#b48ead>default</span><span>;
</span><span>        </span><span style=color:#b48ead>virtual double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const </span><span>= </span><span style=color:#d08770>0</span><span>;
</span><span>    };
</span><span>    
</span><span>    </span><span style=color:#b48ead>template</span><span>&lt;</span><span style=color:#b48ead>typename</span><span> T>
</span><span>    </span><span style=color:#b48ead>struct </span><span>Model : </span><span style=color:#a3be8c>Concept </span><span>{
</span><span>        T data;
</span><span>        </span><span style=color:#8fa1b3>Model</span><span>(T </span><span style=color:#bf616a>value</span><span>) : </span><span style=color:#bf616a>data</span><span>(std::</span><span style=color:#bf616a>move</span><span>(value)) {}
</span><span>        </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const override </span><span>{ </span><span style=color:#b48ead>return</span><span> data.</span><span style=color:#bf616a>area</span><span>(); }
</span><span>    };
</span><span>    
</span><span>    std::unique_ptr&lt;Concept> object;
</span><span>
</span><span>    </span><span style=color:#b48ead>template</span><span>&lt;</span><span style=color:#b48ead>typename</span><span> T>
</span><span>    </span><span style=color:#8fa1b3>Shape</span><span>(T </span><span style=color:#bf616a>obj</span><span>) : </span><span style=color:#bf616a>object</span><span>(std::</span><span style=color:#bf616a>make_unique</span><span>&lt;Model&lt;T>>(std::</span><span style=color:#bf616a>move</span><span>(obj))) {}
</span><span>    
</span><span>    </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const </span><span>{ </span><span style=color:#b48ead>return</span><span> object-></span><span style=color:#bf616a>area</span><span>(); }
</span><span>};
</span></code></pre><p><code>Circle</code> and <code>Square</code> don't need to inherit from anything:<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span style=color:#b48ead>struct </span><span>Circle {
</span><span>    </span><span style=color:#b48ead>double</span><span> radius;
</span><span>    </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const </span><span>{ </span><span style=color:#b48ead>return</span><span> M_PI * radius * radius; }
</span><span>};
</span><span>
</span><span style=color:#b48ead>struct </span><span>Square {
</span><span>    </span><span style=color:#b48ead>double</span><span> side;
</span><span>    </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const </span><span>{ </span><span style=color:#b48ead>return</span><span> side * side; }
</span><span>};
</span></code></pre><p>And now we get value semantics at the API level:<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span style=color:#b48ead>int </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    std::vector&lt;Shape> shapes;  </span><span style=color:#65737e>// No pointers!
</span><span>    shapes.</span><span style=color:#bf616a>emplace_back</span><span>(</span><span style=color:#bf616a>Circle</span><span>{</span><span style=color:#d08770>5.0</span><span>});
</span><span>    shapes.</span><span style=color:#bf616a>emplace_back</span><span>(</span><span style=color:#bf616a>Square</span><span>{</span><span style=color:#d08770>4.0</span><span>});
</span><span>    
</span><span>    </span><span style=color:#b48ead>for </span><span>(</span><span style=color:#b48ead>const auto</span><span>& shape : shapes) {
</span><span>        std::cout &lt;&lt; "</span><span style=color:#a3be8c>Area: </span><span>" &lt;&lt; shape.</span><span style=color:#bf616a>area</span><span>() &lt;&lt; "</span><span style=color:#96b5b4>\n</span><span>";
</span><span>    }
</span><span>}
</span></code></pre><p>Look at <code>main()</code>: no <code>unique_ptr</code>, no template parameters at the call site, just <code>Shape</code>. The polymorphic machinery is entirely hidden.<p>The pattern requires some boilerplate: a <code>Concept</code> base class, a templated <code>Model</code> that wraps concrete types, and a <code>unique_ptr</code> to hide the heap allocation. These names ("Concept" and "Model") are the standard terminology for this pattern. The template constructor accepts any type with the required methods, and type checking happens at template instantiation.<p>The same technique powers <code>std::function</code> and <code>std::any</code>.<h3 id=rust-first-class-trait-objects>Rust: first-class trait objects</h3><p>Look back at the very first Rust example:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>let</span><span> shapes: Vec&lt;Box&lt;dyn Shape>> = vec![
</span><span>    Box::new(Circle { radius: </span><span style=color:#d08770>5.0 </span><span>}),
</span><span>    Box::new(Square { side: </span><span style=color:#d08770>4.0 </span><span>}),
</span><span>];
</span></code></pre><p>That's already type erasure: Rust's <code>dyn Trait</code> is <em>built-in</em> type erasure. The <code>Box&lt;dyn Shape></code> erases the concrete type behind a trait object, giving you runtime polymorphism with the same trait you'd use for static dispatch.<p>The key difference from C++: <em>no boilerplate</em>. Because traits are non-intrusive, Rust doesn't need the Concept/Model workaround. The compiler generates the vtable automatically, trait bounds are checked at the point of use, and object safety rules are enforced at compile time.<h3 id=rust-the-c-style>Rust: the C++ style</h3><p>You can also use the C++ pattern in Rust if you want a cleaner API:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>use </span><span>std::f64::consts::</span><span style=color:#d08770>PI</span><span>;
</span><span>
</span><span style=color:#b48ead>trait </span><span>ShapeTrait {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64</span><span>;
</span><span>}
</span><span>
</span><span style=color:#b48ead>struct </span><span>Circle { </span><span style=color:#bf616a>radius</span><span>: </span><span style=color:#b48ead>f64 </span><span>}
</span><span>
</span><span style=color:#b48ead>impl </span><span>ShapeTrait </span><span style=color:#b48ead>for </span><span>Circle {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64 </span><span>{ </span><span style=color:#d08770>PI </span><span>* </span><span style=color:#bf616a>self</span><span>.radius * </span><span style=color:#bf616a>self</span><span>.radius }
</span><span>}
</span><span>
</span><span style=color:#b48ead>struct </span><span>Square { </span><span style=color:#bf616a>side</span><span>: </span><span style=color:#b48ead>f64 </span><span>}
</span><span>
</span><span style=color:#b48ead>impl </span><span>ShapeTrait </span><span style=color:#b48ead>for </span><span>Square {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64 </span><span>{ </span><span style=color:#bf616a>self</span><span>.side * </span><span style=color:#bf616a>self</span><span>.side }
</span><span>}
</span><span>
</span><span style=color:#b48ead>struct </span><span>Shape {
</span><span>    </span><span style=color:#bf616a>inner</span><span>: Box&lt;dyn ShapeTrait>,
</span><span>}
</span><span>
</span><span style=color:#b48ead>impl </span><span>Shape {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>new</span><span>&lt;T: ShapeTrait + </span><span style=color:#b48ead>'static</span><span>>(</span><span style=color:#bf616a>shape</span><span>: T) -> </span><span style=color:#b48ead>Self </span><span>{
</span><span>        Shape { inner: Box::new(shape) }
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64 </span><span>{ </span><span style=color:#bf616a>self</span><span>.inner.</span><span style=color:#96b5b4>area</span><span>() }
</span><span>}
</span><span>
</span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    </span><span style=color:#b48ead>let</span><span> shapes: Vec&lt;Shape> = vec![
</span><span>        Shape::new(Circle { radius: </span><span style=color:#d08770>5.0 </span><span>}),
</span><span>        Shape::new(Square { side: </span><span style=color:#d08770>4.0 </span><span>}),
</span><span>    ];
</span><span>    
</span><span>    </span><span style=color:#b48ead>for</span><span> shape in &shapes {
</span><span>        println!("</span><span style=color:#a3be8c>Area: </span><span style=color:#d08770>{}</span><span>", shape.</span><span style=color:#96b5b4>area</span><span>());
</span><span>    }
</span><span>}
</span></code></pre><p>Now you have <code>Vec&lt;Shape></code> instead of <code>Vec&lt;Box&lt;dyn Shape>></code>. This gives you:<ul><li>a cleaner public API;<li>the ability to add methods to <code>Shape</code> that aren't on the trait;<li>encapsulation: the <code>Box</code> is an implementation detail you could change later.</ul><p>The tradeoff is that you lose flexibility at call sites: with <code>Box&lt;dyn Trait></code> directly, callers can choose between <code>Box</code>, <code>Rc</code>, or references depending on their needs.<p>In practice, this C++-style wrapper pattern is rare in Rust. The trait system's flexibility and non-intrusiveness means <code>Box&lt;dyn Trait></code> is usually good enough, and the extra indirection of a wrapper struct doesn't buy you much.<h2 id=where-c-has-the-edge>Where C++ has the edge</h2><p>Rust's built-in type erasure is convenient, but C++'s manual approach offers more flexibility in certain scenarios. Whether that flexibility is worth the boilerplate is a question I'll leave to you and your therapist.<ol><li><p><strong>Small buffer optimization</strong> - C++'s <code>std::function</code> stores small callables inline, avoiding heap allocation (see Raymond Chen's <a href="https://devblogs.microsoft.com/oldnewthing/20200514-00/?p=103749">explanation of how this works</a>). Rust's <code>Box&lt;dyn Trait></code> always heap-allocates<sup class=footnote-reference id=fr-sbo-1><a href=#fn-sbo>2</a></sup>.</p><li><p><strong>Custom storage</strong> - C++'s manual approach gives you full control over how the erased type is stored. You can use arena allocation, custom allocators, or other memory layouts. Rust can do this too, but it's harder.</p><li><p><strong>More flexible interface definition</strong> - Rust trait objects have restrictions: traits with generic methods, methods returning <code>Self</code>, or methods taking <code>self</code> by value aren't <a href=https://doc.rust-lang.org/reference/items/traits.html#object-safety>object-safe</a>. You also can't combine arbitrary traits - <code>dyn TraitA + TraitB</code> only works when <code>TraitB</code> is an auto trait like <code>Send</code> or <code>Sync</code>. C++ templates don't have these limitations since you control the <code>Concept</code> interface directly.</p></ol><h2 id=conclusion>Conclusion</h2><p>C++ and Rust both support type erasure, but with different tradeoffs. Rust's <code>dyn Trait</code> makes the common case trivial: no boilerplate, non-intrusive traits, and the compiler handles the vtable. C++ requires manual implementation but offers more flexibility: no object safety restrictions, and <code>std::function</code> provides SBO out of the box for callables. For custom type erasure, both languages require extra effort if you want optimizations like SBO or custom storage.<p>Code samples available on <a href=https://github.com/waifod/code_samples/tree/main/2026-01-24_polymorphism_type_erasure>GitHub</a>.<p>This post was inspired by David Álvarez Rosa's <a href=https://beta.alvarezrosa.com/posts/deriving-type-erasure/><em>Deriving Type Erasure</em></a>.<section class=footnotes><ol class=footnotes-list><li id=fn-newtype><p>If you need to implement a foreign trait for a foreign type, you can use the newtype pattern as a workaround for the <a href=https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules>orphan rule</a>: wrap the foreign type in your own struct and implement the trait on that. <a href=#fr-newtype-1>↩</a></p><li id=fn-sbo><p>The custom type erasure implementation shown earlier in this post uses <code>unique_ptr</code>, which also heap-allocates. SBO is an optimization you'd have to implement yourself in either language. The difference is that C++ ships with it for the callable case via <code>std::function</code>, while Rust's standard library doesn't provide an equivalent. <a href=#fr-sbo-1>↩</a></p></ol></section></article><nav class=post-navigation><header class=post-navigation-title><h2>Read More Posts</h2><hr></header><div class=post-navigation-buttons><a aria-label="Next article" href=https://waifod.dev/blog/my-metal/ rel=next> <span aria-hidden=true>&lt; [</span>My metal<span aria-hidden=true>]</span> </a><span aria-hidden=true role=separator>::</span><a aria-label="Prev article" href=https://waifod.dev/blog/software-i-like/ rel=prev> <span aria-hidden=true>[</span>Software I like<span aria-hidden=true>] ></span> </a></div></nav></main><footer class=footer><address class=socials><ul><li><a aria-label="atom feed" title="atom feed" class=social-link href=https://waifod.dev/atom.xml> <svg aria-label="feed icon" role=img><use aria-hidden=true href=https://waifod.dev/images/social_icons/atom.svg#icon /></svg> </a><li><a aria-label=github class=social-link href=https://github.com/waifod rel=me title=github> <svg aria-label="github icon" role=img><use aria-hidden=true href=https://waifod.dev/images/social_icons/github.svg#icon /></svg> </a><li><a aria-label=linkedin class=social-link href=https://www.linkedin.com/in/waifod/ rel=me title=linkedin> <svg aria-label="linkedin icon" role=img><use aria-hidden=true href=https://waifod.dev/images/social_icons/linkedin.svg#icon /></svg> </a><li><a aria-label=email class=social-link href=mailto:waifod@pm.me rel=me title=email> <svg aria-label="email icon" role=img><use aria-hidden=true href=https://waifod.dev/images/social_icons/email.svg#icon /></svg> </a></ul></address><p class=copyright><span>© <time>2026</time> Matteo Durante</span> <span>Powered by <a href=https://www.getzola.org>Zola</a></span> <span>Theme by <a href=https://eyalkalderon.com>ebkalderon</a></span></footer>