<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content="default-src 'self'; style-src-attr 'unsafe-inline'" http-equiv=Content-Security-Policy><title>Polymorphism in C++ and Rust: type erasure | よ waifod</title><link as=font crossorigin href=https://waifod.dev/fonts/FiraCode-Regular.woff2 rel=preload type=font/woff2><link as=font crossorigin href=https://waifod.dev/fonts/FiraCode-Bold.woff2 rel=preload type=font/woff2><link href="https://waifod.dev/css/style.css?h=287f84ed6c66dca911c6" rel=stylesheet><link href=https://waifod.dev/favicon.svg rel=icon type=text/svg+xml><script src="https://waifod.dev/js/auto-close-popover-on-resize.js?h=4ef87d6fc7b98b22e044" defer></script><script src="https://waifod.dev/js/copy-code-to-clipboard.js?h=b34dc626be3e4c8a0f55" defer></script><link href=https://waifod.dev/blog/polymorphism-type-erasure/ rel=canonical><link title="よ waifod" href=https://waifod.dev/atom.xml rel=alternate type=application/atom+xml><meta content="Matteo Durante" name=author><meta content="In which I teach myself C++ type erasure, and discover why Rust's trait system makes most of it unnecessary…" name=description><meta content="index, follow" name=robots><meta content=#211f1a name=theme-color><meta content=dark name=color-scheme><meta content="Polymorphism in C++ and Rust: type erasure" property=og:title><meta content=article property=og:type><meta content=https://waifod.dev/blog/polymorphism-type-erasure/ property=og:url><meta content="In which I teach myself C++ type erasure, and discover why Rust's trait system makes most of it unnecessary…" property=og:description><meta content="よ waifod" property=og:site_name><meta content=2026-01-25T12:03:42.413501045+00:00 property=og:updated_time><meta content=2026-01-24T00:00:00+00:00 property=article:published_time><meta content=c++ property=article:tag><meta content=rust property=article:tag><meta content=programming property=article:tag><meta content=patterns property=article:tag><body class=layout-center data-theme=terminus><header class=header><div class=header-container><span class=header-logo-container> <a href=https://waifod.dev> <span class=logo>よ waifod</span> </a> </span></div><nav aria-label="Main Menu" class=main-menu><a class=skip-to-content href=#main>Skip to main content</a><button class=main-menu-dropdown-button popovertarget=nav-menu>Menu</button><ul aria-label="Site Navigation" class=main-menu-items id=nav-menu popover><li><a href=https://waifod.dev/blog/>blog</a><li><a href=https://waifod.dev/tags/>tags</a><li><a href=https://github.com/waifod target=_blank>github</a></ul></nav></header><main id=main><article class="post content"><header><h1 class=post-title><a href=https://waifod.dev/blog/polymorphism-type-erasure/>Polymorphism in C++ and Rust: type erasure</a></h1><ul class="post-meta hidden"><li title="Published on 2026-01-24"><time datetime=2026-01-24>2026.01.24</time><li aria-hidden=true role=separator>::<li title="961 words"><time datetime=PT5M>5 min</time> read</ul><div class=post-tags><span>#<a href=https://waifod.dev/tags/c/ rel=tag>c++</a></span><span>#<a href=https://waifod.dev/tags/rust/ rel=tag>rust</a></span><span>#<a href=https://waifod.dev/tags/programming/ rel=tag>programming</a></span><span>#<a href=https://waifod.dev/tags/patterns/ rel=tag>patterns</a></span></div></header><p>In which I teach myself C++ type erasure, and discover why Rust's trait system makes most of it unnecessary.</p><span id=continue-reading></span><h2 id=the-problem-polymorphism-and-its-limitations>The problem: polymorphism and its limitations</h2><p>Let's start with a simple problem: you want to calculate areas of different shapes. The traditional object-oriented solution uses inheritance and virtual functions.<h3 id=classic-dynamic-polymorphism>Classic dynamic polymorphism</h3><p>C++ with virtual functions:<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>cmath</span><span>>
</span><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>iostream</span><span>>
</span><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>vector</span><span>>
</span><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>memory</span><span>>
</span><span>
</span><span style=color:#b48ead>struct </span><span>Shape {
</span><span>    </span><span style=color:#b48ead>virtual </span><span style=color:#8fa1b3>~Shape</span><span>() = </span><span style=color:#b48ead>default</span><span>;
</span><span>    </span><span style=color:#b48ead>virtual double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const </span><span>= </span><span style=color:#d08770>0</span><span>;
</span><span>};
</span><span>
</span><span style=color:#b48ead>struct </span><span>Circle : </span><span style=color:#a3be8c>Shape </span><span>{
</span><span>    </span><span style=color:#b48ead>double</span><span> radius_;
</span><span>    </span><span style=color:#8fa1b3>Circle</span><span>(</span><span style=color:#b48ead>double </span><span style=color:#bf616a>r</span><span>) : </span><span style=color:#bf616a>radius_</span><span>(r) {}
</span><span>    </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const override </span><span>{ </span><span style=color:#b48ead>return</span><span> M_PI * radius_ * radius_; }
</span><span>};
</span><span>
</span><span style=color:#b48ead>struct </span><span>Square : </span><span style=color:#a3be8c>Shape </span><span>{
</span><span>    </span><span style=color:#b48ead>double</span><span> side_;
</span><span>    </span><span style=color:#8fa1b3>Square</span><span>(</span><span style=color:#b48ead>double </span><span style=color:#bf616a>s</span><span>) : </span><span style=color:#bf616a>side_</span><span>(s) {}
</span><span>    </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const override </span><span>{ </span><span style=color:#b48ead>return</span><span> side_ * side_; }
</span><span>};
</span><span>
</span><span style=color:#b48ead>int </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    std::vector&lt;std::unique_ptr&lt;Shape>> shapes;
</span><span>    shapes.</span><span style=color:#bf616a>emplace_back</span><span>(std::</span><span style=color:#bf616a>make_unique</span><span>&lt;Circle>(</span><span style=color:#d08770>5.0</span><span>));
</span><span>    shapes.</span><span style=color:#bf616a>emplace_back</span><span>(std::</span><span style=color:#bf616a>make_unique</span><span>&lt;Square>(</span><span style=color:#d08770>4.0</span><span>));
</span><span>    
</span><span>    </span><span style=color:#b48ead>for </span><span>(</span><span style=color:#b48ead>const auto</span><span>& shape : shapes) {
</span><span>        std::cout &lt;&lt; "</span><span style=color:#a3be8c>Area: </span><span>" &lt;&lt; shape-></span><span style=color:#bf616a>area</span><span>() &lt;&lt; "</span><span style=color:#96b5b4>\n</span><span>";
</span><span>    }
</span><span>}
</span></code></pre><p>Rust with trait objects:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>use </span><span>std::f64::consts::</span><span style=color:#d08770>PI</span><span>;
</span><span>
</span><span style=color:#b48ead>trait </span><span>Shape {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64</span><span>;
</span><span>}
</span><span>
</span><span style=color:#b48ead>struct </span><span>Circle { </span><span style=color:#bf616a>radius</span><span>: </span><span style=color:#b48ead>f64 </span><span>}
</span><span>
</span><span style=color:#b48ead>impl </span><span>Shape </span><span style=color:#b48ead>for </span><span>Circle {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64 </span><span>{ </span><span style=color:#d08770>PI </span><span>* </span><span style=color:#bf616a>self</span><span>.radius * </span><span style=color:#bf616a>self</span><span>.radius }
</span><span>}
</span><span>
</span><span style=color:#b48ead>struct </span><span>Square { </span><span style=color:#bf616a>side</span><span>: </span><span style=color:#b48ead>f64 </span><span>}
</span><span>
</span><span style=color:#b48ead>impl </span><span>Shape </span><span style=color:#b48ead>for </span><span>Square {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64 </span><span>{ </span><span style=color:#bf616a>self</span><span>.side * </span><span style=color:#bf616a>self</span><span>.side }
</span><span>}
</span><span>
</span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    </span><span style=color:#b48ead>let</span><span> shapes: Vec&lt;Box&lt;dyn Shape>> = vec![
</span><span>        Box::new(Circle { radius: </span><span style=color:#d08770>5.0 </span><span>}),
</span><span>        Box::new(Square { side: </span><span style=color:#d08770>4.0 </span><span>}),
</span><span>    ];
</span><span>    
</span><span>    </span><span style=color:#b48ead>for</span><span> shape in &shapes {
</span><span>        println!("</span><span style=color:#a3be8c>Area: </span><span style=color:#d08770>{}</span><span>", shape.</span><span style=color:#96b5b4>area</span><span>());
</span><span>    }
</span><span>}
</span></code></pre><p>This works, but it has limitations:<ol><li>Pointer semantics - you must use pointers/references (<code>std::unique_ptr</code>, <code>Box</code>) in your API;<li>Intrusive - types must inherit from the base class (C++) or implement the trait (Rust).</ol><p>What if you want polymorphism with value semantics at the API level?<h2 id=external-polymorphism>External polymorphism</h2><p>In C++, traditional polymorphism has a fundamental limitation: types must inherit from a base class. This is <em>intrusive</em>: you can't make existing types polymorphic without modifying them.<p>External polymorphism solves this by wrapping types in a polymorphic interface. This is also the first step toward type erasure:<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>cmath</span><span>>
</span><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>iostream</span><span>>
</span><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>memory</span><span>>
</span><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>vector</span><span>>
</span><span>
</span><span style=color:#65737e>// Existing types - they don't inherit from anything
</span><span style=color:#b48ead>struct </span><span>Circle {
</span><span>    </span><span style=color:#b48ead>double</span><span> radius;
</span><span>    </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const </span><span>{ </span><span style=color:#b48ead>return</span><span> M_PI * radius * radius; }
</span><span>};
</span><span>
</span><span style=color:#b48ead>struct </span><span>Square {
</span><span>    </span><span style=color:#b48ead>double</span><span> side;
</span><span>    </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const </span><span>{ </span><span style=color:#b48ead>return</span><span> side * side; }
</span><span>};
</span><span>
</span><span style=color:#65737e>// External polymorphism: wrap types in a polymorphic interface
</span><span style=color:#b48ead>struct </span><span>ShapeWrapper {
</span><span>    </span><span style=color:#b48ead>virtual </span><span style=color:#8fa1b3>~ShapeWrapper</span><span>() = </span><span style=color:#b48ead>default</span><span>;
</span><span>    </span><span style=color:#b48ead>virtual double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const </span><span>= </span><span style=color:#d08770>0</span><span>;
</span><span>};
</span><span>
</span><span style=color:#b48ead>template</span><span>&lt;</span><span style=color:#b48ead>typename</span><span> T>
</span><span style=color:#b48ead>struct </span><span>ShapeWrapperImpl : </span><span style=color:#a3be8c>ShapeWrapper </span><span>{
</span><span>    T shape_;
</span><span>    </span><span style=color:#8fa1b3>ShapeWrapperImpl</span><span>(T </span><span style=color:#bf616a>s</span><span>) : </span><span style=color:#bf616a>shape_</span><span>(std::</span><span style=color:#bf616a>move</span><span>(s)) {}
</span><span>    </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const override </span><span>{ </span><span style=color:#b48ead>return</span><span> shape_.</span><span style=color:#bf616a>area</span><span>(); }
</span><span>};
</span><span>
</span><span style=color:#b48ead>int </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    std::vector&lt;std::unique_ptr&lt;ShapeWrapper>> shapes;
</span><span>    shapes.</span><span style=color:#bf616a>emplace_back</span><span>(std::</span><span style=color:#bf616a>make_unique</span><span>&lt;ShapeWrapperImpl&lt;Circle>>(</span><span style=color:#bf616a>Circle</span><span>{</span><span style=color:#d08770>5.0</span><span>}));
</span><span>    shapes.</span><span style=color:#bf616a>emplace_back</span><span>(std::</span><span style=color:#bf616a>make_unique</span><span>&lt;ShapeWrapperImpl&lt;Square>>(</span><span style=color:#bf616a>Square</span><span>{</span><span style=color:#d08770>4.0</span><span>}));
</span><span>    
</span><span>    </span><span style=color:#b48ead>for </span><span>(</span><span style=color:#b48ead>const auto</span><span>& shape : shapes) {
</span><span>        std::cout &lt;&lt; "</span><span style=color:#a3be8c>Area: </span><span>" &lt;&lt; shape-></span><span style=color:#bf616a>area</span><span>() &lt;&lt; "</span><span style=color:#96b5b4>\n</span><span>";
</span><span>    }
</span><span>}
</span></code></pre><p>This pattern lets you add polymorphism to types you don't control. But it still exposes pointers in your API.<p>Rust doesn't need this pattern because traits are <em>non-intrusive</em> by design. You can implement traits for types without modifying them<sup class=footnote-reference id=fr-newtype-1><a href=#fn-newtype>1</a></sup>:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>use </span><span>std::f64::consts::</span><span style=color:#d08770>PI</span><span>;
</span><span>
</span><span style=color:#b48ead>struct </span><span>ThirdPartyCircle { </span><span style=color:#bf616a>radius</span><span>: </span><span style=color:#b48ead>f64 </span><span>}
</span><span>
</span><span style=color:#b48ead>trait </span><span>Shape {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64</span><span>;
</span><span>}
</span><span>
</span><span style=color:#b48ead>impl </span><span>Shape </span><span style=color:#b48ead>for </span><span>ThirdPartyCircle {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64 </span><span>{ </span><span style=color:#d08770>PI </span><span>* </span><span style=color:#bf616a>self</span><span>.radius * </span><span style=color:#bf616a>self</span><span>.radius }
</span><span>}
</span></code></pre><p>This is a key difference: C++ needs the external polymorphism pattern as a workaround, while Rust's trait system provides it naturally.<h2 id=enter-type-erasure>Enter type erasure</h2><p>Type erasure solves a specific problem: how do you get polymorphic behavior with value semantics at the API level?<p>Consider <code>std::function</code> in C++:<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>functional</span><span>>
</span><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>iostream</span><span>>
</span><span>
</span><span style=color:#b48ead>void </span><span style=color:#8fa1b3>print_result</span><span>(std::function&lt;</span><span style=color:#b48ead>int</span><span>(</span><span style=color:#b48ead>int</span><span>, </span><span style=color:#b48ead>int</span><span>)> </span><span style=color:#bf616a>op</span><span>) {
</span><span>    std::cout &lt;&lt; </span><span style=color:#bf616a>op</span><span>(</span><span style=color:#d08770>3</span><span>, </span><span style=color:#d08770>4</span><span>) &lt;&lt; "</span><span style=color:#96b5b4>\n</span><span>";
</span><span>}
</span><span>
</span><span style=color:#b48ead>int </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    </span><span style=color:#65737e>// Different types, same interface
</span><span>    </span><span style=color:#bf616a>print_result</span><span>([](</span><span style=color:#b48ead>int</span><span> a, </span><span style=color:#b48ead>int</span><span> b) { </span><span style=color:#b48ead>return</span><span> a + b; });     </span><span style=color:#65737e>// Lambda
</span><span>    </span><span style=color:#bf616a>print_result</span><span>(std::</span><span style=color:#bf616a>multiplies</span><span>&lt;</span><span style=color:#b48ead>int</span><span>>{});                 </span><span style=color:#65737e>// Functor
</span><span>    </span><span style=color:#bf616a>print_result</span><span>([](</span><span style=color:#b48ead>int</span><span> a, </span><span style=color:#b48ead>int</span><span> b) { </span><span style=color:#b48ead>return</span><span> a * b; });     </span><span style=color:#65737e>// Different lambda
</span><span>}
</span></code></pre><p>Notice:<ul><li>we pass by value, not by pointer;<li>each callable has a different type;<li>no inheritance required;<li>the concrete type is "erased" behind <code>std::function</code>.</ul><p>This is type erasure: hiding the concrete type behind a uniform interface while maintaining <em>value semantics</em>.<section class="alert note" aria-labelledby=WhIt5clm role=note><div class="alert-icon alert-icon-note"></div><div class=alert-content role=presentation><strong aria-hidden=true class=alert-title id=WhIt5clm>NOTE</strong><p>Type erasure gives you value semantics at the API level. The heap allocation still happens, but it's an implementation detail hidden from callers.</div></section><h2 id=implementing-type-erasure>Implementing type erasure</h2><p>Now let's see how each language implements type erasure.<h3 id=c-the-manual-approach>C++: the manual approach</h3><p>C++ doesn't provide type erasure as a language feature, and instead you implement it using the "external polymorphism" pattern (see Sean Parent's <a href="https://www.youtube.com/watch?v=2bLkxj6EVoM"><em>Inheritance Is The Base Class of Evil</em></a> talk and Klaus Iglberger's <a href=https://www.oreilly.com/library/view/c-software-design/9781098113155/><em>C++ Software Design</em></a> for in-depth treatments):<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>cmath</span><span>>
</span><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>memory</span><span>>
</span><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>iostream</span><span>>
</span><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>vector</span><span>>
</span><span>
</span><span style=color:#b48ead>struct </span><span>Shape {
</span><span>    </span><span style=color:#b48ead>struct </span><span>Concept {
</span><span>        </span><span style=color:#b48ead>virtual </span><span style=color:#8fa1b3>~Concept</span><span>() = </span><span style=color:#b48ead>default</span><span>;
</span><span>        </span><span style=color:#b48ead>virtual double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const </span><span>= </span><span style=color:#d08770>0</span><span>;
</span><span>    };
</span><span>    
</span><span>    </span><span style=color:#b48ead>template</span><span>&lt;</span><span style=color:#b48ead>typename</span><span> T>
</span><span>    </span><span style=color:#b48ead>struct </span><span>Model : </span><span style=color:#a3be8c>Concept </span><span>{
</span><span>        T data;
</span><span>        </span><span style=color:#8fa1b3>Model</span><span>(T </span><span style=color:#bf616a>value</span><span>) : </span><span style=color:#bf616a>data</span><span>(std::</span><span style=color:#bf616a>move</span><span>(value)) {}
</span><span>        </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const override </span><span>{ </span><span style=color:#b48ead>return</span><span> data.</span><span style=color:#bf616a>area</span><span>(); }
</span><span>    };
</span><span>    
</span><span>    std::unique_ptr&lt;Concept> object;
</span><span>
</span><span>    </span><span style=color:#b48ead>template</span><span>&lt;</span><span style=color:#b48ead>typename</span><span> T>
</span><span>    </span><span style=color:#8fa1b3>Shape</span><span>(T </span><span style=color:#bf616a>obj</span><span>) : </span><span style=color:#bf616a>object</span><span>(std::</span><span style=color:#bf616a>make_unique</span><span>&lt;Model&lt;T>>(std::</span><span style=color:#bf616a>move</span><span>(obj))) {}
</span><span>    
</span><span>    </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const </span><span>{ </span><span style=color:#b48ead>return</span><span> object-></span><span style=color:#bf616a>area</span><span>(); }
</span><span>};
</span><span>
</span><span style=color:#65737e>// Concrete types - no inheritance required
</span><span style=color:#b48ead>struct </span><span>Circle {
</span><span>    </span><span style=color:#b48ead>double</span><span> radius;
</span><span>    </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const </span><span>{ </span><span style=color:#b48ead>return</span><span> M_PI * radius * radius; }
</span><span>};
</span><span>
</span><span style=color:#b48ead>struct </span><span>Square {
</span><span>    </span><span style=color:#b48ead>double</span><span> side;
</span><span>    </span><span style=color:#b48ead>double </span><span style=color:#8fa1b3>area</span><span>() </span><span style=color:#b48ead>const </span><span>{ </span><span style=color:#b48ead>return</span><span> side * side; }
</span><span>};
</span><span>
</span><span style=color:#b48ead>int </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    std::vector&lt;Shape> shapes;  </span><span style=color:#65737e>// Value semantics!
</span><span>    shapes.</span><span style=color:#bf616a>emplace_back</span><span>(</span><span style=color:#bf616a>Circle</span><span>{</span><span style=color:#d08770>5.0</span><span>});
</span><span>    shapes.</span><span style=color:#bf616a>emplace_back</span><span>(</span><span style=color:#bf616a>Square</span><span>{</span><span style=color:#d08770>4.0</span><span>});
</span><span>    
</span><span>    </span><span style=color:#b48ead>for </span><span>(</span><span style=color:#b48ead>const auto</span><span>& shape : shapes) {
</span><span>        std::cout &lt;&lt; "</span><span style=color:#a3be8c>Area: </span><span>" &lt;&lt; shape.</span><span style=color:#bf616a>area</span><span>() &lt;&lt; "</span><span style=color:#96b5b4>\n</span><span>";
</span><span>    }
</span><span>}
</span></code></pre><p>The pattern requires some boilerplate: a <code>Concept</code> base class, a templated <code>Model</code> that wraps concrete types, and a <code>unique_ptr</code> to hide the heap allocation. These names ("Concept" and "Model") are the standard terminology for this pattern. The template constructor accepts any type with the required methods, and type checking happens at template instantiation.<p>This is the same technique used internally by <code>std::function</code> and <code>std::any</code>.<h3 id=rust-first-class-trait-objects>Rust: first-class trait objects</h3><p>Look back at the very first Rust example:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>let</span><span> shapes: Vec&lt;Box&lt;dyn Shape>> = vec![
</span><span>    Box::new(Circle { radius: </span><span style=color:#d08770>5.0 </span><span>}),
</span><span>    Box::new(Square { side: </span><span style=color:#d08770>4.0 </span><span>}),
</span><span>];
</span></code></pre><p>That's already type erasure: Rust's <code>dyn Trait</code> is <em>built-in</em> type erasure. The <code>Box&lt;dyn Shape></code> erases the concrete type behind a trait object, giving you runtime polymorphism with the same trait you'd use for static dispatch.<p>The key difference from C++: <em>no boilerplate</em>. Because traits are non-intrusive, Rust doesn't need the Concept/Model workaround. The compiler generates the vtable automatically, trait bounds are checked at the point of use, and object safety rules are enforced at compile time.<h3 id=rust-the-c-style>Rust: the C++ style</h3><p>You can also use the C++ pattern in Rust if you want a cleaner API:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>use </span><span>std::f64::consts::</span><span style=color:#d08770>PI</span><span>;
</span><span>
</span><span style=color:#b48ead>trait </span><span>ShapeTrait {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64</span><span>;
</span><span>}
</span><span>
</span><span style=color:#b48ead>struct </span><span>Circle { </span><span style=color:#bf616a>radius</span><span>: </span><span style=color:#b48ead>f64 </span><span>}
</span><span>
</span><span style=color:#b48ead>impl </span><span>ShapeTrait </span><span style=color:#b48ead>for </span><span>Circle {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64 </span><span>{ </span><span style=color:#d08770>PI </span><span>* </span><span style=color:#bf616a>self</span><span>.radius * </span><span style=color:#bf616a>self</span><span>.radius }
</span><span>}
</span><span>
</span><span style=color:#b48ead>struct </span><span>Square { </span><span style=color:#bf616a>side</span><span>: </span><span style=color:#b48ead>f64 </span><span>}
</span><span>
</span><span style=color:#b48ead>impl </span><span>ShapeTrait </span><span style=color:#b48ead>for </span><span>Square {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64 </span><span>{ </span><span style=color:#bf616a>self</span><span>.side * </span><span style=color:#bf616a>self</span><span>.side }
</span><span>}
</span><span>
</span><span style=color:#b48ead>struct </span><span>Shape {
</span><span>    </span><span style=color:#bf616a>inner</span><span>: Box&lt;dyn ShapeTrait>,
</span><span>}
</span><span>
</span><span style=color:#b48ead>impl </span><span>Shape {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>new</span><span>&lt;T: ShapeTrait + </span><span style=color:#b48ead>'static</span><span>>(</span><span style=color:#bf616a>shape</span><span>: T) -> </span><span style=color:#b48ead>Self </span><span>{
</span><span>        Shape { inner: Box::new(shape) }
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>area</span><span>(&</span><span style=color:#bf616a>self</span><span>) -> </span><span style=color:#b48ead>f64 </span><span>{ </span><span style=color:#bf616a>self</span><span>.inner.</span><span style=color:#96b5b4>area</span><span>() }
</span><span>}
</span><span>
</span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>main</span><span>() {
</span><span>    </span><span style=color:#b48ead>let</span><span> shapes: Vec&lt;Shape> = vec![
</span><span>        Shape::new(Circle { radius: </span><span style=color:#d08770>5.0 </span><span>}),
</span><span>        Shape::new(Square { side: </span><span style=color:#d08770>4.0 </span><span>}),
</span><span>    ];
</span><span>    
</span><span>    </span><span style=color:#b48ead>for</span><span> shape in &shapes {
</span><span>        println!("</span><span style=color:#a3be8c>Area: </span><span style=color:#d08770>{}</span><span>", shape.</span><span style=color:#96b5b4>area</span><span>());
</span><span>    }
</span><span>}
</span></code></pre><p>Now you have <code>Vec&lt;Shape></code> instead of <code>Vec&lt;Box&lt;dyn Shape>></code>. This gives you:<ul><li>a cleaner public API;<li>the ability to add methods to <code>Shape</code> that aren't on the trait;<li>encapsulation - the <code>Box</code> is an implementation detail you could change later.</ul><p>The tradeoff is that you lose flexibility at call sites. With <code>Box&lt;dyn Trait></code> directly, callers can choose between <code>Box</code>, <code>Rc</code>, or references depending on their needs.<p>In practice, this C++-style wrapper pattern is rare in Rust. The trait system's flexibility and non-intrusiveness means <code>Box&lt;dyn Trait></code> is usually good enough, and the extra indirection of a wrapper struct doesn't buy you much.<h2 id=where-c-has-the-edge>Where C++ has the edge</h2><p>Rust's built-in type erasure is convenient, but C++'s manual approach offers more flexibility in certain scenarios:<ol><li><p><strong>Small buffer optimization</strong> - C++'s <code>std::function</code> stores small callables inline, avoiding heap allocation (see Raymond Chen's <a href="https://devblogs.microsoft.com/oldnewthing/20200514-00/?p=103749">explanation of how this works</a>). Rust's <code>Box&lt;dyn Trait></code> always heap-allocates. That said, if you're implementing custom type erasure (as shown in this post), you have to implement SBO yourself in both languages. Neither makes it easy. C++ just ships with it for the callable case.</p><li><p><strong>More flexible interface definition</strong> - Rust trait objects have restrictions: traits with generic methods, methods returning <code>Self</code>, or methods taking <code>self</code> by value aren't object-safe. You also can't combine arbitrary traits - <code>dyn TraitA + TraitB</code> only works when <code>TraitB</code> is an auto trait like <code>Send</code> or <code>Sync</code>. C++ templates don't have these limitations since you control the <code>Concept</code> interface directly.</p><li><p><strong>Custom storage</strong> - C++'s manual approach gives you full control over how the erased type is stored. You can use arena allocation, custom allocators, or other memory layouts. Rust can do this too, but it's not simpler than C++.</p></ol><h2 id=conclusion>Conclusion</h2><p>C++ and Rust both support type erasure, but with different tradeoffs. Rust's <code>dyn Trait</code> makes the common case trivial: no boilerplate, non-intrusive traits, and the compiler handles the vtable. C++ requires manual implementation but offers more control when you need SBO, custom storage, or want to bypass object safety restrictions.<p>Code samples available on <a href=https://github.com/waifod/blog_code_samples/tree/main/2026-01-24_polymorphism_type_erasure>GitHub</a>.<section class=footnotes><ol class=footnotes-list><li id=fn-newtype><p>If you need to implement a foreign trait for a foreign type, you can use the newtype pattern: wrap the foreign type in your own struct and implement the trait on that. <a href=#fr-newtype-1>↩</a></p></ol></section></article><nav class=post-navigation><header class=post-navigation-title><h2>Read More Posts</h2><hr></header><div class=post-navigation-buttons><a aria-label="Next article" href=https://waifod.dev/blog/my-metal/ rel=next> <span aria-hidden=true>&lt; [</span>My metal<span aria-hidden=true>]</span> </a><span aria-hidden=true role=separator>::</span><a aria-label="Prev article" href=https://waifod.dev/blog/software-i-like/ rel=prev> <span aria-hidden=true>[</span>Software I like<span aria-hidden=true>] ></span> </a></div></nav></main><footer class=footer><address class=socials><ul><li><a aria-label="atom feed" title="atom feed" class=social-link href=https://waifod.dev/atom.xml> <svg aria-label="feed icon" role=img><use aria-hidden=true href=https://waifod.dev/images/social_icons/atom.svg#icon /></svg> </a><li><a aria-label=github class=social-link href=https://github.com/waifod rel=me title=github> <svg aria-label="github icon" role=img><use aria-hidden=true href=https://waifod.dev/images/social_icons/github.svg#icon /></svg> </a><li><a aria-label=linkedin class=social-link href=https://www.linkedin.com/in/waifod/ rel=me title=linkedin> <svg aria-label="linkedin icon" role=img><use aria-hidden=true href=https://waifod.dev/images/social_icons/linkedin.svg#icon /></svg> </a><li><a aria-label=email class=social-link href=mailto:waifod@pm.me rel=me title=email> <svg aria-label="email icon" role=img><use aria-hidden=true href=https://waifod.dev/images/social_icons/email.svg#icon /></svg> </a></ul></address><p class=copyright><span>© <time>2026</time> Matteo Durante</span> <span>Powered by <a href=https://www.getzola.org>Zola</a></span> <span>Theme by <a href=https://eyalkalderon.com>ebkalderon</a></span></footer>